const bodyparser = require('co-body');

const REQUEST_BODY_DESC = 'request body';
const REQUEST_QUERY_DESC = 'request query string';

const validationCode = 'KOA_REQUEST_VALIDATION_ERROR';

function buildError(message) {
    const e = new Error(message);
    e.code = validationCode;
    return e;
}

function isValidationError(e) {
    return e && e.code == validationCode;
}

module.exports = {
    buildError: buildError,
    isValidationError: isValidationError,
    validationCode: validationCode,
    body: schema => async (ctx, next) => {
        if (!ctx.request.body) {
            ctx.request.body = await bodyparser.form(ctx.req);
        }
        
        await doSchema(REQUEST_BODY_DESC, schema, ctx.request.body, next);
    },
    query: schema => async (ctx, next) => {
        console.log(ctx.request.query);
        
        await doSchema(REQUEST_QUERY_DESC, schema, ctx.request.query, next);
    },
    required: async (sourceDesc, key, value) => {
        if (value === undefined) {
            throw buildError(`Expected "${key}" in ${sourceDesc}.`);
        }
    },
    optional: async (sourceDesc, key, value) => {}
};

function assertEmpty(sourceDesc, set) {
    if (set.size > 0) {
        throw buildError(`Unexpected fields in ${sourceDesc}: ${set}`);
    }
}

async function doSchema(desc, schema, parameterMap, next) {
    const unprocessedKeys = new Set(Object.keys(parameterMap || {}));
    
    schema = schema || {};
    await Promise.all(Object.keys(schema).map(key => {
        unprocessedKeys.delete(key);
        return schema[key](desc, key, parameterMap[key]);
    }));
    
    assertEmpty(desc, unprocessedKeys);
    
    await next();
}